# AnalysisAnnualCycle.R
#
# This function plots the monthly averages of a variable,
# for both modelled and observed. 
# For this to be successful, the dataset **MUST START AT JAN 1**
# AND be a integer number of years in length.
#
# Gab Abramowitz CCRC, UNSW 2012 (palshelp at gmail dot com)
#
AnnualCycle = function(obslabel,acdata,varname,ytext,legendtext,
	timestepsize,whole,modlabel='no'){
	######
	if(!whole){ # we need a whole number of years for this to run
		CheckError('DS3: AnnualCycle analysis requires a whole number of years of data.')
	}
	ncurves = length(acdata[1,]) # Number of curves in final plot:
	ntsteps = length(acdata[,1]) # Number of timesteps in data:
	tstepinday=86400/timestepsize # time steps in a day
	ndays = ntsteps/tstepinday # number of days in data set
	nyears=as.integer(ndays/365) # find # years in data set
	month=getMonthDays(leap=FALSE) # get non-leap year month days (in PALSconstants)
	data_monthly=matrix(NA,12,ncurves) # initialise monthly averages
	# For each curve (i.e. model, obs etc):
	for(p in 1:ncurves){
		# Reshape into timestep columns, row days:
		data_days=matrix(acdata[,p],ncol=tstepinday,byrow=TRUE) 
		avday=c() # initialise
		# Transform data into daily averages:
		for(i in 1:ndays){
			avday[i]=mean(data_days[i,]) # calc daily average value
		}	
		# Transform daily means into monthly means:
		for(m in 1:12){ # for each month
			data_month=0 # initialise
			for(k in 1:nyears){ # for each year of data set
				# Add all daily averages for a given month
				# over all data set years:
				data_month = data_month + 
					sum(avday[(month$start[m]+(k-1)*365):
					(month$start[m+1]-1 +(k-1)*365) ] )
			}
			# Then divide by the total number of days added above:
			data_monthly[m,p]=data_month/(month$length[m]*nyears)
		}
	}
	xloc=c(1:12) # set location of x-coords
	plotcolours=getPlotColours() # in PALSconstants
	# Plot model output result:
	yaxmin=min(data_monthly) # y axis minimum in plot
	yaxmax=max(data_monthly)+0.18*(max(data_monthly)-yaxmin) # y axis maximum in plot
	plot(xloc,data_monthly[,1],type="l",xaxt="n",xlab='Month',ylab=ytext,
		lwd=3,col=plotcolours[1],ylim=c(yaxmin,yaxmax),cex.lab=1.2,cex.axis=1.3)
	# Add other curves:
	if(ncurves>1){
		pscore = c()
		for(p in 2:ncurves){ # for each additional curve
			lines(xloc,data_monthly[,p],lwd=3,col=plotcolours[p])
			# Score is normalised mean error:
			pscore[p-1] = sum(abs(data_monthly[,p] - data_monthly[,1])) /
				sum(abs(mean(data_monthly[,1]) - data_monthly[,1]))
		}	
	}
	axis(1,at=c(2,4,6,8,10,12),labels=c('2','4','6','8','10','12'),cex.axis=1.3)
	if(modlabel=='no'){ # i.e. an obs analysis
		title(paste('Average monthly ',varname[1],':   Obs - ',obslabel,
			sep=''),cex.main=1.1) # add title
	}else{
		title(paste('Average monthly ',varname[1],':   Obs - ',obslabel,'   Model - ',
			modlabel,sep=''),cex.main=1.1) # add title
	}
	legend(1,max(data_monthly)+0.15*(max(data_monthly)-yaxmin),legendtext[1:ncurves],
		lty=1,col=plotcolours[1:ncurves],lwd=3,bty="n",yjust=0.8)
	if(ncurves>1){
		scorestring = paste(signif(pscore,digits=3),collapse=', ')
		scoretext = paste('Score: ',scorestring,'\n','(NME)',sep='')
		text(8,max(data_monthly)+0.1*(max(data_monthly)-yaxmin),scoretext,pos=4,offset=1)
	}
	return()
} # End function AnnualCycle

BenchAnnualCycle = function(analysisType,varname,units,ytext,legendtext){
	checkUsage(analysisType)
	setOutput(analysisType)
	# Load model and obs data:
	obs = GetFluxnetVariable(varname,getObservedFluxDataFilePath(analysisType),units)
	model = GetModelOutput(varname,getModelOutputFilePath(analysisType),units)
	# Check compatibility between model and obs (same dataset):
	CheckTiming(model$timing,obs$timing)
	# Load benchmark names and paths:
	UserBenchPaths = getUserBenchPaths()
	UserBenchNames = getUserBenchNames()
	nbench = length(UserBenchNames) # number of benchmarks
	bench = matrix(NA,nbench,length(obs$data))
	# Load benchmark data:
	for(b in 1:nbench){
		if(substr(UserBenchNames[b],1,5)=='B_Emp'){ 
			# this is an empirical benchmark
			bvarname = paste(varname[1],'_',
				substr(UserBenchNames[b],6,nchar(UserBenchNames[b])),sep='')
			tmp_flx = GetBenchmarkVariable(bvarname,UserBenchPaths[b])
			# Check emp benchmark is based on same data set and version as obs:
			if(b==1){
				CheckVersionCompatibility(UserBenchPaths[b],
					getObservedFluxDataFilePath(analysisType))
			}
		}else{
			# this benchmark is a model simulation
			tmp_flx = GetModelOutput(varname,UserBenchPaths[b],units)
		}
		# Check benchmark data timing is compatible with obs:
		if(b==1){
			CheckTiming(tmp_flx$timing,obs$timing)
		}
		# For now, if requested benchmark variable doesn't exist in benchmark
		# file, stop script:
		if(is.null(tmp_flx)){
			CheckError(paste('B4: Could not find benchmark variable "',bvarname,
				'" in benchmark netcdf file.',sep=''))	
		}
		bench[b,] = tmp_flx$data
	}
	# Create data matrix for function:
	acdata=matrix(NA,length(model$data),(2+nbench))
	acdata[,1] = obs$data
	acdata[,2] = model$data
	for(b in 1:nbench){
		acdata[,(b+2)] = bench[b,]
	}
	# Call AnnualCycle plotting function:
	AnnualCycle(getObsLabel(analysisType),acdata,varname,ytext,legendtext,
		obs$timing$tstepsize,obs$timing$whole,getModLabel(analysisType))
}

ModelAnnualCycle = function(analysisType,varname,units,ytext,legendtext){
	checkUsage(analysisType)
	setOutput(analysisType)
	# Load model and obs data:
	obs = GetFluxnetVariable(varname,getObservedFluxDataFilePath(analysisType),units)
	model = GetModelOutput(varname,getModelOutputFilePath(analysisType),units)
	# Check compatibility between model and obs (same dataset):
	CheckTiming(model$timing,obs$timing)
	# Create data matrix for function:
	acdata=matrix(NA,length(model$data),2)
	acdata[,1] = obs$data
	acdata[,2] = model$data
	# Call AnnualCycle plotting function:
	AnnualCycle(getObsLabel(analysisType),acdata,varname,ytext,legendtext,
		obs$timing$tstepsize,obs$timing$whole,getModLabel(analysisType))
}

ObsAnnualCycle = function(analysisType,varname,units,ytext,legendtext){
	checkUsage(analysisType)
	setOutput(analysisType)
	# Load obs data:
	obs = GetFluxnetVariable(varname,getObservedFluxDataFilePath(analysisType),units)
	# Create data matrix for function:
	acdata=matrix(NA,length(obs$data),1)
	acdata[,1] = obs$data
	# Call annual cycle plotting function:
	AnnualCycle(getObsLabel(analysisType),acdata,varname,
		ytext,legendtext,obs$timing$tstepsize,obs$timing$whole)
	# copyOutput(analysisType) # copy to png device if pdf requested
}